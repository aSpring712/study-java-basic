# 클래스가 필요한 이유
자바 세상은 **클래스와 객체**로 이루어져 있다.

클래스가 왜 필요한지 이해하기 위해 다음 문제를 풀어보자.

## 문제: 학생 정보 출력 프로그램 만들기 (ClassStart1)
## 문제: 이전 문제에 배열을 사용하자 (ClassStart2)

# 클래스 도입 (Student, ClassStart3)
위 문제들에 클래스를 도입해서 해결해보자.
클래스를 사용해서 학생이라는 개념을 만들고, 각각의 학생 별로 본인의 이름, 나이, 성적을 관리하는 것이다.

**클래스에 정의한 변수들을 멤버 변수, 또는 필드**라 한다.
- **멤버 변수(Member Variable)**: 이 변수들은 특정 클래스에 소속된 멤버이기 때문에 이렇게 부른다.
- **필드(Field)**: 데이터 항목을 가리키는 전통적인 용어이다. 데이터베이스, 엑셀 등에서
데이터 각각의 항목을 필드라 한다.
- 자바에서 멤버 변수, 필드는 같은 뜻이다. 클래스에 소속된 변수를 뜻한다.

**클래스는 관례상 대문자로 시작하고 낙타 표기법을 사용한다.** <br/>
e.g. `Student`, `User`, `MemberService`

### 클래스와 사용자 정의 타입
- 타입은 데이터의 종류나 형태를 나타낸다.
- `int`라고 하면 정수 타입, `String`이라고 하면 문자 타입이다.
- 학생(`Student`)이라는 타입을 만들면 되지 않을까?
- 클래스를 사용하면 `int`, `String`과 같은 타입을 직접 만들 수 있다.
- 사용자가 직접 정의하는 사용자 정의 타입을 만들려면 설계도가 필요하다. 이 **설계도가 바로 클래스**이다.
- 설계도인 클래스를 사용해서 **실제 메모리에 만들어진 실체를 객체 또는 인스턴스**라 한다.
- 클래스를 통해서 사용자가 원하는 종류의 데이터 타입을 마음껏 정의할 수 있다.

### 용어: 클래스, 객체, 인스턴스
클래스는 설계도이고, 이 설계도를 기반으로 실제 메모리에 만들어진 실체를 객체 또는 인스턴스라 한다.
둘다 같은 의미로 사용된다. <br/>
여기서는 학생(`Student`) 클래스를 기반으로 학생1(`student1`), 학생2(`student2`)
객체 또는 인스턴스를 만들었다.

코드 분석
### 1. 변수 선언
```java
Student student1 // Student 변수 선언
```
- `Student student1`
  - `Student` 타입을 받을 수 있는 변수를 선언한다.
  - `int`는 정수를, `String`은 문자를 담을 수 있듯이 `Student`는 `Student` 타입의 객체(인스턴스)를
  받을 수 있다.

### 2. 객체(인스턴스) 생성

```java
student1 = new Student() // Student 객체(인스턴스) 생성
```
`student1 = new Student()` 코드를 나누어 분석해보자.
- 객체를 사용하려면 먼저 설계도인 클래스를 기반으로 객체(인스턴스)를 생성해야 한다.
- `new Student()`: `new`는 새로 생성한다는 뜻이다. `new Student()`는 `Student` 클래스 정보를
기반으로 새로운 객체를 생성하라는 뜻이다. 이렇게 하면 메모리에 실제 `Student` 객체(인스턴스)를 생성한다.
- 객체를 생성할 때는 `new 클래스명()`을 사용하면 된다. 마지막에 `()`도 추가해야 한다.
- `Student` 클래스는 `String name`, `int age`, `int grade` 멤버 변수를 가지고 있다.
이 변수를 사용하는데 필요한 메모리 공간도 함께 확보한다.

### 3. 참조값 보관
```java
student1 = x001; // Student 인스턴스 참조값 보관
```
- 객체를 생성하면 자바는 메모리 어딘가에 있는 이 객체에 접근할 수 있는 참조값(주소)(`x001`)을 반환한다.
  - 여기서 `x001`이라고 표현한 것이 참조값이다. (실제로 `x001`처럼 표현되는 것은 아니고 이해를 돕기 위한 예시)
- `new` 키워드를 통해 객체가 생성되고 나면 참조값을 반환한다. 앞서 선언한 변수인 `Student student1`에
생성된 객체의 참조값(`x001`)을 보관한다.
- `Student student1` 변수는 이제 메모리에 존재하는 실제 `Student` 객체(인스턴스)의 참조값을 가지고 있다.
  - `student1` 변수는 방금 만든 객체에 접근할 수 있는 참조값을 가지고 있다. 따라서 이 변수를 통해서
  객체를 접근(참조)할 수 있다. 쉽게 이야기해서 `student1` 변수를 통해 메모리에 있는 실제 객체를 접근하고
  사용할 수 있다.

### 참조값을 변수에 보관해야 하는 이유
객체를 생성하는 `new Student()` 코드 자체에는 아무런 이름이 없다. 이 코드는 단순히 `Student` 클래스를 기반으로
메모리에 실제 객체를 만드는 것이다. 따라서 생성한 객체에 접근할 수 있는 방법이 필요하다. 이런 이유로 객체를
생성할 때 반환되는 참조값을 어딘가에 보관해두어야 한다. 앞서 `Student student1` 변수에 참조값 `x001`을
저장해두었으므로 저장한 참조값(`x001`)을 통해서 실제 메모리에 존재하는 객체에 접근할 수 있다.

지금까지 설명한 내용을 간단히 풀어보면 다음과 같다.
```java
Stduent student1 = new Student(): // 1. Student 객체 생성
Student student1 = x001; // 2. new Student()의 결과로 x001 참조값 반환
student1 = x001; // 3. 최종 결과
```
이후에 학생2(`Student2`)까지 생성하면 다음과 같이 `Student` 객체(인스턴스)가 메모리에 2개 생성된다.
각각 참조값이 다르므로 서로 구분할 수 있다.

참조값을 확인하고 싶다면 다음과 같이 객체를 담고 있는 변수를 출력해보면 된다.
```java
System.out.println(student1);
System.out.println(student2);
```

### 출력 결과
```text
class1.Student@7a81197d
class1.Student@2f2c9b19
```
@ 앞은 패키지 + 클래스 정보를 뜻한다. @ 뒤에 16진수는 참조값을 뜻한다.

# 객체 사용
클래스를 통해 생성한 객체를 사용하려면 먼제 메모리에 존재하는 객체에 접근해야 한다.
객체에 접근하려면 `.`(점, dot)을 사용하면 된다.
```java
// 객체 값 대입
student1.name = "학생1";
student1.age = 15;
student1.grade = 90;

// 객체 값 사용
System.out.println("이름:" + student1.name + " 나이:" + student1.age + " 성적:" + student1.grade);
```

## 객체에 값 대입
객체가 가지고 있는 멤버 변수(`name`, `age`, `grade`)에 값을 대입하려면 먼저 객체에 접근해야 한다. <br/>
객체에 접근하려면 `.`(점, dot) 키워드를 사용하면 된다. 이 키워드는 변수(`student1`)에 들어있는
참조값(`x001`)을 읽어서 메모리에 존재하는 객체에 접근한다.

순서를 간단히 풀어보면 다음과 같다.
```java
student1.name = "학생1" // 1. student1 객체의 name 멤버 변수에 값 대입
x001.name = "학생1" // 2. 변수에 있는 참조값을 통해 실제 객체에 접근, 해당 객체의 name 멤버 변수에 값 대입
```
`student1.`(dot)이라고 하면 `student1` 변수가 가지고 있는 참조값을 통해 실제 객체에 접근한다. <br/>
`student1`은 `x001`이라는 참조값을 가지고 있으므로 `x001` 위치에 있는 `Student` 객체에 접근한다.

## 객체 값 읽기
객체의 값을 읽는 것도 앞서 설명한 내용과 같다. `.`(점, dot) 키워드를 통해 참조값을 사용해서
객체에 접근한 다음에 원하는 작업을 하면 된다.
```java
// 1. 객체 값 읽기
System.out.println("이름: " + student1.name);
// 2. 변수에 있는 참조값을 통해 실제 객체에 접근하고, name 멤버 변수에 접근한다.
System.out.println("이름: " + x001.name);
// 3. 객체의 멤버 변수의 값을 읽어옴
System.out.println("이름: " + "학생1");
```

---
# 클래스, 객체, 인스턴스 정리
### 클래스 - Class
클래스는 객체를 생성하기 위한 '틀' 또는 '설계도'이다. 클래스는 객체가 가져야 할 속성(변수)과 기능(메서드)를
정의한다. 예를 들어 학생이라는 클래스는 속성으로 `name`, `age`, `grade`를 가진다. <br/>
속성(변수)
- 틀: 붕어빵 틀을 생각해보자. 붕어빵 틀은 붕어빵이 아니다! 이렇게 생긴 붕어빵이 나왔으면 좋겠다고 만드는
틀일 뿐이다. 실제 먹을 수 있는 것이 아니다. 실제 먹을 수 있는 팥 붕어빵을 객체 또는 인스턴스라 한다.
- 설계도: 자동차 설계도를 생각해보자. 자동차 설계도는 자동차가 아니다! 설계도는 실제 존재하는 것이 아니라
개념으로만 있는 것이다. 설계도를 통해 생산한 실제 존재하는 흰색 테슬라 모델 Y 자동차를 객체 또는 인스턴스라 한다.

### 객체 - Object
객체는 클래스에서 정의한 속성과 기능을 가진 실체이다. 객체는 서로 독립적인 상태를 가진다. <br/>
예를 들어 위 코드에서 `student1`은 학생1의 속성을 가지는 객체이고, `student2`는 학생2의 속성을
가지는 객체이다. `student1`과 `student2`는 같은 클래스에서 만들어졌지만, 서로 다른 객체이다.

### 인스턴스 - Instance
인스턴스는 특정 클래스로부터 생성된 객체를 의미한다. 그래서 객체와 인스턴스라는 용어는 자주 혼용된다.
인스턴스는 주로 객체가 어떤 클래스에 속해있는지 강조할 때 사용한다. 예를 들어서 `student1` 객체는
`Student` 클래스의 인스턴스다. 라고 표현한다.

### 객체 vs 인스턴스
둘다 클래스에서 나온 실체라는 의미에서 비슷하게 사용되지만, 용어상 인스턴스는 객체보다 좀 더 관계에 초점을 맞춘
단어이다. 보통 `student1`은 `Student`의 객체이다. 라고 말하는 대신 `student1`은 `Student`의
인스턴스이다. 라고 특정 클래스와의 관계를 명확히 할 때 인스턴스라는 용어를 주로 사용한다. <br/>
좀 더 쉽게 풀어보자면, 모든 인스턴스는 객체지만, 우리가 인스턴스라고 부르는 순간은 특정 클래스로부터
그 객체가 생성되었음을 강조하고 싶을 때이다. 예를 들어 `student1`은 객체이지만, 이 객체가 `Student`
클래스로부터 생성된다는 점을 명확히 하기 위해 `student1`을 `Student`의 인스턴스라고 부른다.

하지만 둘다 클래스에서 나온 실체라는 핵심 의미는 같기 때문에 보통 둘을 구분하지 않고 사용한다.

---

# 배열 도입 - 시작 (ClassStart4)
클래스와 객체 덕분에 학생 데이터를 구조적으로 이해하기 쉽게 변경할 수 있었다. <br/>
마치 실제 학생이 있고, 그 안에 각 학생의 정보가 있는 것 같다. 따라서 사람이 이해하기도 편리하다. <br/>
이제 각각의 학생 별로 객체를 생성하고, 해당 객체에 학생의 데이터를 관리하면 된다.

하지만 코드를 보면 아쉬운 부분이 있는데, 바로 학생을 출력하는 부분이다.
```java
System.out.println("이름: " + student1.name + " 나이: " + student1.age + ...);
System.out.println("이름: " + student2.name + " 나이: " + student2.age + ...);
```
새로운 학생이 추가될 때 마다 출력하는 부분도 함께 추가해야 한다.

배열을 사용하면 특정 타입을 연속한 데이터 구조로 묶어서 편리하게 관리할 수 있다. <br/>
`Student` 클래스를 사용한 변수들도 `Student` 타입이기 때문에 학생도 배열을 사용해서
하나의 데이터 구조로 묶어서 관리할 수 있다.

`Student` 타입을 사용하는 배열을 도입해보자.

# 배열 도입 - 리펙토링 (ClassStart5)
배열을 사용한 덕분에 출력에서 다음과 같이 for문을 도입할 수 있게 되었다.

## 배열 선언 최적화
우리가 직접 정의한 `Student` 타입도 일반적인 변수와 동일하게 배열을 생성할 때 포함할 수 있다.
```java
Student[] students = new Student[]{student1, student2};
```
생성과 선언을 동시에 하는 경우 다음과 같이 더 최적화 할 수 있다.
```java
Student[] students = {student1, student2};
```

## for문 최적화
배열을 사용한 덕분에 for문을 사용해서 반복 작업을 깔끔하게 처리할 수 있다.

### for문 도입
```java
for (int i = 0; i < students.length; i++){
	System.out.println("이름:" + students[i].name + " 나이:" + students[i].age + ...);
}
```

### for문 - 반복 요소를 변수에 담아서 처리하기
```java
for (int i = 0; i < students.length; i++) {
	Student s = student[i];
	System.out.println("이름:" + s.name + " 나이:" + s.age + ...);
}
```
`student[i].name`, `student[i].age` 처럼 `student[i]`를 자주 접근하는 것이 번거롭다면
반복해서 사용하는 객체를 `Students s`와 같은 변수에 담아두고 사용해도 된다. <br/>
물론 이런 경우에는 다음과 같이 향상된 for문을 사용하는 것이 가장 깔끔하다.

### 향상된 for문(Enhanced For Loop)
```java
for (Student s : students) {
      System.out.println("이름:" + s.name + " 나이:" + s.age + "성적:" + s.grade);
}
```